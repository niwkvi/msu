Документация
#31
Иничкина Наталья
М1-19


План
- Описание метода
	- Краевая задача
	- Метод Нюстрема 4-го порядка
	- Метод Ньютона
- Описание программы
	- Задание функции
	- main_31.c
	- odu_31.c
	- Построение графика


Описание метода

Дана краевая задача вида
y''+p(x,y)y'+q(x,y)y=f(x,y)
y(x_0)=y_0
y(x_1)=y_1
x\in[x_0, x_1]

Данное уравнение второго порядка можно свести к системе из двух уравнений первого порядка вида
y'=z
z'=-p(x,y)-q(x)y+f(x,y)
y(x_0)=y_0
y(x_1)=y_1
x\in[x_0, x_1]

Для решения вышеописанной задачи используется метод Ньютона, приводящий к задаче Коши вида
y'=z
z'=-p(x,y)-q(x,y)y+f(x,y)
y(x_0)=y_0
y(x_1)=t
x\in[x_0, x_1]


Метод Нюстрема 4-го порядка

Были выведены следующие формулы (Хайрер - Нежесткие задачи)
k_i = -p(x_0+c_i*h, y_0+c_i*h*z_0+h^2*\sum(_a_ij*k_j))(z_0+h*\sum(a_ij*k_j))-
-q(x_0+c_i*h, y_o+c_i*h*z_0+h^2*\sum(_a_ij*k_j))(y_o+c_i*h*z_0+h^2*\sum(_a_ij*k_j))+
+f(x_0+c_i*h, y_o+c_i*h*z_0+h^2*\sum(_a_ij*k_j))
y_1=y_0+h*z_0+h^2*\sum(_b_i*k_i)
z_1=z_0+h*\sum(b_i*k_i)
i=1,...,4

Таблица коэффициентов (Хайрер - Нежесткие задачи)
	0	
	1/2	1/8
c_i	1/2	1/8	0		_a_ij
	1	0	0	1/2
_b_i		1/6	1/6	1/6

	1/2
	0	1/2			a_ij
	0	0	1
	1/6	2/6	2/6	1/6	b_i

Изначально берется введенное пользователем число точек разбиения n, после чего оно увеличивается в 2 раза до тех пор, пока среднеквадратичная ошибка между решениями с числом точек n и n/2 не становится меньше заданного пользователем eps.

Подбор параметра t осуществляется так, чтобы полученное решение задачи Коши удовлетворяло условию
y(x_1)=y_1
Для этого задается целевая функция F(t)=|y_1-_y(t)|, которую необходимо занулить.
y_1 - точно значение на правом конце
_y(t) - вычисленное значение на правом конце


Метод Ньютона

Для поиска параметра t используется метод Ньютона (метод касательных), в котором поиск решения осуществляется путем построения последовательных приближений. 

Основная идея метода заключается в том, что задается начальное приближение вблизи предположительного корня, после чего строится касательная к графику исследуемой функции в точке приближения, для которой находится пересечение с осью абсцисс. Эта точка берется в качестве следующего приближения. Процесс продолжается, пока не достигается необходимая точность.

x_(n+1)=x_n-f(x_n)/f'(x_n)


Описание программы

Задание уравнения происходит при помощи файла funks_31.c, функции в которых изменяются пользователем - f(x,y), p(x,y), q(x, y) и real(x), в последнюю необходимо записать функцию, являющуюся точным решением уравнения, а также текстового файла in.txt.

Функции f(x, y), p(x, y), q(x, y) и real(x) в файле funks_31.c
double f(double x, double y);
double p(double x, double y);
double q(double x, double y);
double real(double x); - если точное решение неизвестно, то следует прописать return 0;

Входные данные подаются в программу через текстовый файл in.txt, который должен размещать в той же папке, что и исполняемый файл программы.

Входной текстовый файл in.txt состоит из 6 значений, записанных через пробел:
double x0 - левая граница интервала
double x1 - правая граница интервала
double y0 - значение решения в точке x0
double y1 - значение решения в точке x1
int n - начальное число интервалов
double eps - погрешность вычислений

Выход программы содержится в файлах out.txt и graph.png.
Выходной текстовый файл out.txt состоит из n+2 строк:
- первая строка содержит вычисленное число итераций
- последующие n+1 строки содержат по 2 значения через пробел - x и вычисленный для этого x программой y

Программа реализует решение краевой задачи второго порядка при помощи его сведения к системе уравнений первого порядка, метода Нюстрема 4-го порядка и метода Ньютона.


main_31.c

В данном файле объявлены глобально следующие массивы:
xs - массив иксов
ys - массив вычисленных ответов
ys_real - массив правильных ответов

Имеется вспомогательная функция, для вывода текстов некоторых ошибок:
int errors(int error_code);
Аргументы:
- error_code - соответствующий код ошибки
Выход:
- -1 + печать текста-описания ошибки в поток ошибок stderr

Чтение входных данных осуществляется функцией int input:
int input(char *in_filename, double *x0, double *x1, double *y0, double *y1, int *n, double *eps);
Аргументы:
- in_filename - имя входного текстового файла
- x0, x1, y0, y1, n, eps - указатели на переменные, в которые записываются соответствующие данные из входного текстового файла
Выход:
- 0 - успешное завершение
- -1 - ошибка + описание ошибки через функцию int errors

Выделение памяти для глобальных массивов происходит в функции:
int new_mem(int best_n);
Аргументы:
- best_n - размер создаваемых массивов;
Выход:
- 0 - успешное завершение
- -1 - ошибка + описание ошибки через функцию int errors

Освобождение памяти для глобальных массивов происходит в функции:
void free_mem();

Печать правильного ответа осуществляется в файл out.txt, который создается в той же папке, где находится исполняемый файл программы.
Печать производится функцией:
int output(char *out_filename, int n, int best_n);
Аргументы:
- out_filename - имя выходного файла (задается в int main())
- n - число изначальных интервалов (задается во входном текстовом файле)
- best_n - полученное оптимальное количество интервалов
Выход:
- 0 - успешное завершение
- -1 - ошибка + описание ошибки через функцию int errors

Вызов решающих функций из odu_31.c осуществляется в функции:
int solve(double x0, double x1, double y0, double y1, int n, double eps, int *best_n);
Аргументы:
- x0, x1, y0, y1, n, eps - данные, полученные из входного текстового файла
- best_n - указатель на переменную, в которую запишется оптимальное число интервалов
Выход:
- 0 - успешное завершение
- -1 - ошибка
В данной функции вычисляется оптимальный z0 и соответствующее best_n, вызывается функция new_mem для выделения памяти для глобальных массивов, после чего заполняется массив ответов ys, массив иксов xs и массив правильных ответов ys_real.

В главной функции int main() объявляются названия входного и выходного текстовых файлов, переменные x0, x1, y0, y1, eps, n, best_n. Также вызываются последовательно функции input, solve, output, draw_graph и free_mem с соответствующей печатью-навигацией в консоль.
Выход:
- 0 - успешное завершение
- -1 - ошибка

В случае успешной работы программы в консоль выведется "Success!".


odu_31.c

Глобально объявлены массивы для коэффициентов Нюстрема и переменная, хранящая количество итераций работы метода Ньютона.

Коэффициента метода Нюстрема 4-го порядка задаются в функции:
void nystrom_init() {
    nystrom_c[0] = 0.0;
    nystrom_c[1] = 1.0 / 2.0;
    nystrom_c[2] = 1.0 / 2.0;
    nystrom_c[3] = 1.0;

    nystrom_a[1][0] = 1.0 / 2.0;
    nystrom_a[2][0] = 0.0;
    nystrom_a[2][1] = 1.0 / 2.0;
    nystrom_a[3][0] = 0.0;
    nystrom_a[3][1] = 0.0;
    nystrom_a[3][2] = 1.0;

    nystrom_a_[1][0] = 1.0 / 8.0;
    nystrom_a_[2][0] = 1.0 / 8.0;
    nystrom_a_[2][1] = 0.0;
    nystrom_a_[3][0] = 0.0;
    nystrom_a_[3][1] = 0.0;
    nystrom_a_[3][2] = 1.0 / 2.0;

    nystrom_b[0] = 1.0 / 6.0;
    nystrom_b[1] = 2.0 / 6.0;
    nystrom_b[2] = 2.0 / 6.0;
    nystrom_b[3] = 1.0 / 6.0;

    nystrom_b_[0] = 1.0 / 6.0;
    nystrom_b_[1] = 1.0 / 6.0;
    nystrom_b_[2] = 1.0 / 6.0;
    nystrom_b_[3] = 0.0;
}

Имеются три вспомогательные функции:
- double dot(double *arr1, double *arr2, int size); - считающая скалярное произведение для двух массивов
- double get_error(double *arr1, double *arr2, int n); - считающая среднеквадратичную ошибку для двух массивов.
- double y_eq(double x, double y1, double y2); - вычисляющая -p(x,y1)y2-q(x,y1)y1+f(x,y1)

Имеется функция, представляющая собой реализацию метода Нюстрема для решения задачи Коши с заданным разбиением интервала:
double nystrom(double x0, double x1, double y0, double z0, int n, double *ys);
Аргументы:
- x0 - левая граница интервала
- x1 - правая граница интервала
- y0 - значение решения в точке x0
- z0 - значение производной решения в точке x0
- n - начальное число интервалов
- ys - массив выделенной памяти длины n+1, в который после исполнения функции будут записаны значения решения в узлах
Выход: 
- вычисленное значение решения на правом конце в точке x1
В данной функции использованы формулы, приведенные выше в разделе Описание метода Нюстрема 4-го порядка.

Имеется функция, осуществляющая подбор оптимального числа интервалов разбиения:
int find_n(double x0, double x1, double y0, double z0, int n, double eps);
Аргументы:
- x0 - левая граница интервала
- x1 - правая граница интервала
- y0 - значение решения в точке x0
- z0 - значение производной решения в точке x0
- n - начальное число интервалов
- eps - погрешность вычислений
Выход: 
- оптимальное число интервалов
Число увеличивается в 2 раза до тех пор, пока среднеквадратичная ошибка между решениями, полученными при числе интервалов n и n/2 не оказывается меньше eps.

Имеется еще одна вспомогательная функция, вызывающая Нюстрема для конкретных z0 и best_n.
double F(double x0, double x1, double y0, double z0, int n, double eps);
Аргументы:
- x0 - левая граница интервала
- double x1 - правая граница интервала
- double y0 - значение решения в точке x0
- z0 - значение производной решения в точке x0
- n - начальное число интервалов
- eps - погрешность вычислений
Выход: 
- вычисленное значение решения на правом конце в точке x1

Главной функцией odu_31.c является функция, реализующая метод Ньютона для решения задачи:
double newton(double x0, double x1, double y0, double y1, int n, double eps);
Аргументы:
- x0 - левая граница интервала
- x1 - правая граница интервала
- y0 - значение решения в точке x0
- y1 - значение решения в точке x1
- n - начальное число интервалов
- eps - погрешность вычислений
Выход: 
- оптимальное z0
В данной функции осуществляется подбор z0, а также подсчет количества итераций, записывающихся в глобальную переменную int iter_num.
Имеется переменная double delta=1e-5, использующаяся в записи представления производной df.

В конце файла представлена еще одна вспомогательная функция, возвращающая вычисленное число итераций для метода Ньютона.


Построение графика

Для построения графика сравнения решения, полученного программой, и точного решения была использована библиотека для отрисовки графиков с открытым исходным кодом pbPlots, написанная на языке C и выложенная в GitHub. Из нее были добавлены в программу файлы pbPlots.h и pbPlots.c, а код из файлов supportLib.h и supportLib.c был использован в файлах draw_graph.h и draw_graph.c, где реализована функция draw_graph, вызывающаяся в main_31.c для построения графика.
На графике присутствуют:
Красная линия - вычисленное программой решение
Синяя линия - точное решение
В случае близкого совпадения решений цвета могут накладываться друг на друга, из-за чего на графике может отображаться либо только красная линия, либо только синяя.
Полученный график сохраняется под названием graph.png в ту же папку, где находится исполняемый файл программы.
Ссылка на pbPlots:
https://github.com/InductiveComputerScience/pbPlots/tree/master/C
